# ============== "Abstract" ci stages used by real stages =======================

# Builds a dev version of a specific Dockerfile (--target dev) using a previous CI
# image or the latest develop image as a cache to speed up the build. Tags and pushes
# the resulting dev image for later stages in the pipeline to use.
#
# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:20.10.12
  stage: build
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to rebuild.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to rebuild.
      - tags
  services:
    - docker:20.10.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$CI_IMAGE_REPO:$CI_COMMIT_REF_NAME
  script:
    - |
      echo "$CI_REGISTRY_PASSWORD" | \
        docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi


      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      CI_DEV_LATEST_BRANCH_TAG=$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CI_DEV_LATEST_BRANCH_TAG"
      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

          # If that didnt work try the latest dev image from develop
          CACHE_IMAGE="$RELEASE_IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
      fi

      EXTRA_BUILD_ARGS=""
      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image path also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      if [[ -n "$BUILD_FROM_IMAGE" ]]; then
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --build-arg FROM_IMAGE=$BUILD_FROM_IMAGE";
        echo "Building from $BUILD_FROM_IMAGE."
      fi

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached so builds caching from this image can use those layers.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image.
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        $EXTRA_BUILD_ARGS \
        $IMAGE_LABELS \
        --target dev \
        --tag $CI_IMAGE_PATH \
        --tag $LATEST_CI_IMAGE \
        -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# Builds a non-dev (no docker build target provided) and fully labelled final image
# and tags and pushes the non-dev and dev images using $TESTED_IMAGE_PREFIX to mark
# them as being successfully tested for the publishing jobs to use.
#
# To extend this stage set the DOCKERFILE_PATH, IMAGE_NAME and DEV_IMAGE_NAME variables.
.build-final-baserow-image:
  image: $CI_UTIL_IMAGE
  stage: build-final
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to rebuild.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to rebuild.
      - tags
  services:
    - docker:20.10.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$RELEASE_IMAGE_REPO:$CI_COMMIT_REF_NAME
  script:
    - |
      echo "$CI_REGISTRY_PASSWORD" | \
        docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$IMAGE_NAME" ]]; then
          echo "Must provide IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi

      # ===== 1. Setup image metadata labels =====
      #Build date for opencontainers
      #rfc 3339 date
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE"
      IMAGE_LABELS="$IMAGE_LABELS --label build-date=$BUILDDATE"
      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.description=$BUILDTITLE"

      # ==== 2. Tag, build and push non-dev image ====

      # Cache from the CI dev image to build the non dev image.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      NON_DEV_CACHE_IMAGE=$CI_IMAGE_REPO/$IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      TARGET_NON_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
      TARGET_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA

      docker pull $CI_IMAGE_PATH

      if ! docker pull $NON_DEV_CACHE_IMAGE ; then
        echo "Failed to find non dev cache image $NON_DEV_CACHE_IMAGE..."
        EXTRA_BUILD_ARGS="";
      else
        echo "Caching from $NON_DEV_CACHE_IMAGE";
        EXTRA_BUILD_ARGS="--cache-from $NON_DEV_CACHE_IMAGE";
      fi
      
      if [[ -n "$BUILD_FROM_IMAGE" ]]; then
        EXTRA_BUILD_ARGS="$EXTRA_BUILD_ARGS --build-arg FROM_IMAGE=$BUILD_FROM_IMAGE";
        IMAGE_LABELS="$IMAGE_LABELS --label built-from-image=$BUILD_FROM_IMAGE"
        if docker pull "$BUILD_FROM_IMAGE"; then
          BUILT_FROM_REVISION=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["org.opencontainers.image.revision"]')
          BUILT_FROM_COMMITURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.commiturl"]')
          BUILT_FROM_CIJOBURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.cijoburl"]')
          BUILT_FROM_MRURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["com.gitlab.ci.mrurl"]')
          BUILT_FROM_VCSURL=$(docker inspect $BUILD_FROM_IMAGE | jq -r '.[0].Config.Labels["vcs-url"]')

          IMAGE_LABELS="$IMAGE_LABELS --label built-from-revision=$BUILD_FROM_REVISION"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-commiturl=$BUILD_FROM_COMMITURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-cijoburl=$BUILD_FROM_CIJOBURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-mrurl=$BUILD_FROM_MRURL"
          IMAGE_LABELS="$IMAGE_LABELS --label built-from-vcsurl=$BUILD_FROM_VCSURL"
        else
          echo "Failed to pull build from image $BUILD_FROM_IMAGE, something has gone wrong"
          exit 1
        fi
      fi

      # Build the normal non-dev image with all the tags and labels.
      docker build \
        --cache-from $CI_IMAGE_PATH \
        $EXTRA_BUILD_ARGS \
        $FORMATTEDTAGLIST \
        $IMAGE_LABELS \
        -t $TARGET_NON_DEV_IMAGE_PATH \
        -f $DOCKERFILE_PATH .;
      docker push $TARGET_NON_DEV_IMAGE_PATH

      # Build the cache image with layer caching enabled. We don't enable it for the image above to reduce its size.
      docker build \
        --cache-from $CI_IMAGE_PATH \
        $EXTRA_BUILD_ARGS \
        $IMAGE_LABELS \
        --build-arg BUILDKIT_INLINE_CACHE=1 \
        -t $NON_DEV_CACHE_IMAGE \
        -f $DOCKERFILE_PATH .;
      docker push $NON_DEV_CACHE_IMAGE

      docker tag $CI_IMAGE_PATH $TARGET_DEV_IMAGE_PATH
      docker push $TARGET_DEV_IMAGE_PATH

# A simple docker based test job which does not run for a TAG pipeline and does not
# check out git.
.docker-image-test-stage:
  stage: test
  image: $CI_UTIL_IMAGE
  interruptible: true
  # We can't use the newer rules: syntax due to https://gitlab.com/gitlab-org/gitlab/-/issues/34756
  except:
    refs:
      # When a pipeline is triggered by an upstream project we don't want to retest.
      - pipelines
      # When a pipeline is triggered by a git commit tag we don't want to retest.
      - tags
  services:
    - docker:20.10.12-dind


