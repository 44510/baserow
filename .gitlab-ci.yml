#before_script:
#  - apt-get update && apt-get -y install make curl gnupg2

stages:
  - build
  - test
  - publish

variables:
  # An image repo which is used for storing and passing images between ci pipeline jobs
  # and also speeding up ci builds by caching from the latest ci image when building.
  CI_IMAGE_REPO: $CI_REGISTRY_IMAGE/ci
  # Any images with tags prefixed with this will be cleaned up automatically by our
  # gitlab cleanup job.
  #
  # ## Note:
  #   These cleanup tag prefixes are needed as gitlab only supports cleanup via tags
  #   over the regex and not per repo/image cleanup settings...
  #
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  CLEANUP_JOB_CI_TAG_PREFIX: ci-latest-
  # Any images with tags prefixed with this will be cleaned up automatically by our
  # gitlab cleanup job.
  #
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  CLEANUP_JOB_BRANCH_TAG_PREFIX: branch-latest-
  # An image repo where dev and normal images will be stored after they have been
  # successfully built and tested.
  IMAGE_REPO: $CI_REGISTRY_IMAGE/testing
  BACKEND_IMAGE_NAME: backend
  BACKEND_DEV_IMAGE_NAME: backend_dev
  WEBFRONTEND_IMAGE_NAME: web-frontend
  WEBFRONTEND_DEV_IMAGE_NAME: web-frontend_dev
  BACKEND_CI_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  DEVELOP_BRANCH_NAME: develop
  DEVELOP_LATEST_TAG: $DEVELOP_BRANCH_NAME-latest

# ============== "Abstract" ci stages used by later real stages =======================

# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:19.03.12
  stage: build
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 1>&2
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 1>&2
          exit 1
      fi


      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      CI_DEV_LATEST_BRANCH_TAG=$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CI_DEV_LATEST_BRANCH_TAG"
      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

        # Then perhaps the latest dev image for this branch
        CACHE_IMAGE="$IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_BRANCH_TAG_PREFIX$TRUNCATED_BRANCH_NAME"
        if ! docker pull $CACHE_IMAGE; then

          # Finally the latest dev image from develop
          CACHE_IMAGE="$IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
        fi
      fi

      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        CACHE_ARG="--cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
        CACHE_ARG=""
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached and re-used in the final publish stage.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build --build-arg BUILDKIT_INLINE_CACHE=1 $CACHE_ARG --target dev --tag $CI_IMAGE_PATH --tag $LATEST_CI_IMAGE -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# To extend this stage set the DOCKERFILE_PATH and DEV_IMAGE_NAME variables.
.publish-baserow-image:
  image: docker:19.03.12
  stage: publish
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$IMAGE_REPO:$CI_COMMIT_REF_NAME
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 1>&2
          exit 1
      fi
      if [[ -z "$IMAGE_NAME" ]]; then
          echo "Must provide IMAGE_NAME as a job variable" 1>&2
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 1>&2
          exit 1
      fi


      # ===== 1. Setup image metadata labels =====
      echo "Building and shipping image to $IMAGE_REPO"
      #Build date for opencontainers
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'" #rfc 3339 date
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE --label build-date=$BUILDDATE"
      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE --label org.opencontainers.image.description=$BUILDTITLE"

      # ==== 2. Tag, build and push non-dev image ====
      # ====== 2.1. If on master and this commit tagged add latest and commit tag tags
      if [[ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]]; then
        VERSIONLABEL=$CI_COMMIT_TAG
        if [[ ! -z "$VERSIONLABEL" ]]; then
          # If we are on master and this commit is tagged then publish this image
          # as the latest.
          ADDITIONALTAGLIST="$ADDITIONALTAGLIST latest";
          ADDITIONALTAGLIST="$ADDITIONALTAGLIST $VERSIONLABEL"
          IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.version=$VERSIONLABEL"
        fi
      fi

      # ====== 2.2. Tag as develop-latest if on develop =====
      if [[ "$CI_COMMIT_BRANCH" = $DEVELOP_BRANCH_NAME ]]; then
        # TODO - Check if this is actually the latest commit on develop before doing
        # this
        ADDITIONALTAGLIST="$ADDITIONALTAGLIST $DEVELOP_LATEST_TAG";
      fi

      # ====== 2.3. Tag and build non dev image =====
      FORMATTEDTAGLIST=""
      if [[ -n "$ADDITIONALTAGLIST" ]]; then
        for TAG in $ADDITIONALTAGLIST; do
          TAGGED_IMAGE=$IMAGE_REPO/$IMAGE_NAME:$TAG
          FORMATTEDTAGLIST="${FORMATTEDTAGLIST} -t $TAGGED_IMAGE ";
        done;
      fi

      # Cache from the CI dev image to build the non dev image.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
      docker pull $CI_IMAGE_PATH
      # Build the normal non-dev image with all the tags and labels.
      docker build --cache-from $CI_IMAGE_PATH $FORMATTEDTAGLIST $IMAGE_LABELS -f $DOCKERFILE_PATH .;

      # ====== 2.4. Push all non dev image tags =====
      if [[ -n "$ADDITIONALTAGLIST" ]]; then
        for TAG in $ADDITIONALTAGLIST; do
          TAGGED_IMAGE=$IMAGE_REPO/$IMAGE_NAME:$TAG
          docker push $TAGGED_IMAGE
        done;
      fi

      # ====== 3. Publish dev image =====
      # Finally we can publish the latest dev image for this branch as the image has
      # now neen tested.

      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      BRANCH_DEV_LATEST_BRANCH_TAG=""

      if [[ "$CI_COMMIT_BRANCH" = $DEVELOP_BRANCH_NAME ]]; then
        BRANCH_DEV_LATEST_BRANCH_TAG=$IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG
      elif [[ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]]; then
        VERSIONLABEL=$CI_COMMIT_TAG
        if [[ ! -z "$VERSIONLABEL" ]]; then
          # only publish dev image as latest if this is a tagged master version.
          # todo : only do if this is the latest tag to prevent rebuilds
          BRANCH_DEV_LATEST_BRANCH_TAG=$IMAGE_REPO/$DEV_IMAGE_NAME
        fi 
      else
        BRANCH_DEV_LATEST_BRANCH_TAG=$IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_BRANCH_TAG_PREFIX$TRUNCATED_BRANCH_NAME
      fi

      if [[ -n "$BRANCH_DEV_LATEST_BRANCH_TAG" ]]; then
        docker tag $CI_IMAGE_PATH $BRANCH_DEV_LATEST_BRANCH_TAG
        docker push $BRANCH_DEV_LATEST_BRANCH_TAG
      fi

# ====================================== BACKEND ======================================
build-backend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

backend-lint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $BACKEND_CI_IMAGE lint

backend-test:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
    - name: postgres:11.3
      alias: db
    - name: liminspace/mjml-tcpserver:0.10
      alias: mjml
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    POSTGRES_USER: baserow
    POSTGRES_PASSWORD: baserow
    POSTGRES_DB: baserow
  script:
    - MJML_IP=$(cat /etc/hosts | awk '{if ($2 == "mjml") print $1;}')
    - ping -w 2 $MJML_IP
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - docker run --name=baserow_backend_test_container --add-host="db:$DB_IP" --add-host="mjml:$MJML_IP" $BACKEND_CI_IMAGE ci-test
    - docker cp baserow_backend_test_container:/baserow/backend/reports reports
    - docker rm baserow_backend_test_container
  artifacts:
    when: always
    paths:
      - reports/pytest_report.html
      - reports/coverage_html/
    reports:
      cobertura: reports/coverage.xml
      junit: reports/report.xml
  coverage: '/^TOTAL.+?(\d+\%)$/'

publish-backend-image:
  extends: .publish-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_IMAGE_NAME
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

# ==================================== WEB-FRONTEND ====================================
build-web-frontend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile

web-frontend-eslint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $WEBFRONTEND_CI_IMAGE eslint
web-frontend-stylelint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $WEBFRONTEND_CI_IMAGE stylelint

web-frontend-test:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --name=baserow_webfrontend_test_container $WEBFRONTEND_CI_IMAGE ci-test
    - docker cp baserow_webfrontend_test_container:/baserow/reports reports
    - docker rm baserow_webfrontend_test_container
  artifacts:
    when: always
    paths:
      - reports/coverage/
    reports:
      cobertura: reports/coverage/cobertura-coverage.xml
      junit: reports/junit.xml
  coverage: '/Lines\s*:\s*(\d+.?\d*)%/'

publish-web-frontend-image:
  extends: .publish-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_IMAGE_NAME
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile
