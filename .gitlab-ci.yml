#before_script:
#  - apt-get update && apt-get -y install make curl gnupg2

stages:
  - build
  - test
  - publish

variables:
  # An image repo which is used for storing and passing images between ci pipeline jobs
  # and also speeding up ci builds by caching from the latest ci image when building.
  CI_IMAGE_REPO: $CI_REGISTRY_IMAGE/ci
  # An image repo where dev and normal images will be stored after they have been
  # successfully built and tested.
  IMAGE_REPO: $CI_REGISTRY_IMAGE/testing
  DEV_LATEST_TAG: dev-latest
  BACKEND_SERVICE_NAME: backend
  WEBFRONTEND_SERVICE_NAME: web-frontend
  BACKEND_CI_IMAGE: $CI_IMAGE_REPO/$BACKEND_SERVICE_NAME:$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_SERVICE_NAME:$CI_COMMIT_SHORT_SHA
  DEVELOP_BRANCH_NAME: develop

# ============== "Abstract" ci stages used by later real stages =======================

# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:19.03.12
  stage: build
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      # Please set: DOCKERFILE_PATH
      # Please set: IMAGE_NAME

      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      DEV_LATEST_BRANCH_TAG=$DEV_LATEST_TAG-$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$IMAGE_NAME:$DEV_LATEST_BRANCH_TAG"

      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

        # Then perhaps the latest dev image for this branch
        CACHE_IMAGE="$IMAGE_REPO/$IMAGE_NAME:$DEV_LATEST_BRANCH_TAG"
        if ! docker pull $CACHE_IMAGE; then

          # Finally the latest dev image from develop
          CACHE_IMAGE="$IMAGE_REPO/$IMAGE_NAME:$DEV_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
        fi
      fi

      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        CACHE_ARG="--cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
        CACHE_ARG=""
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached and re-used in the final publish stage.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build --build-arg BUILDKIT_INLINE_CACHE=1 $CACHE_ARG --target dev --tag $CI_IMAGE_PATH --tag $LATEST_CI_IMAGE -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.publish-baserow-image:
  image: docker:19.03.12
  stage: publish
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$IMAGE_REPO:$CI_COMMIT_REF_NAME
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      # Please set: DOCKERFILE_PATH
      # Please set: IMAGE_NAME

      echo "Building and shipping image to $IMAGE_REPO"
      #Build date for opencontainers
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'" #rfc 3339 date
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE --label build-date=$BUILDDATE"

      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      BRANCH_TAG=$TRUNCATED_BRANCH_NAME-$CI_COMMIT_SHORT_SHA
      LATEST_BRANCH_TAG=latest-$TRUNCATED_BRANCH_NAME

      ADDITIONALTAGLIST="$ADDITIONALTAGLIST $BRANCH_TAG $LATEST_BRANCH_TAG"

      if [[ "$CI_COMMIT_BRANCH" == "$CI_DEFAULT_BRANCH" ]]; then
        VERSIONLABEL=$CI_COMMIT_TAG
        if [[ ! -z "$VERSIONLABEL" ]]; then
          # If we are on master and this commit is tagged then publish this image
          # as the latest.
          ADDITIONALTAGLIST="$ADDITIONALTAGLIST latest";
          ADDITIONALTAGLIST="$ADDITIONALTAGLIST $VERSIONLABEL"
          IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.version=$VERSIONLABEL"
        fi
      fi

      if [[ "$CI_COMMIT_BRANCH" == $DEVELOP_BRANCH_NAME ]]; then
        ADDITIONALTAGLIST="$ADDITIONALTAGLIST $DEV_LATEST_TAG";
      fi

      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE --label org.opencontainers.image.description=$BUILDTITLE"

      FORMATTEDTAGLIST=""
      if [[ -n "$ADDITIONALTAGLIST" ]]; then
        for TAG in $ADDITIONALTAGLIST; do
          TAGGED_IMAGE=$IMAGE_REPO/$IMAGE_NAME:$TAG
          FORMATTEDTAGLIST="${FORMATTEDTAGLIST} -t $TAGGED_IMAGE ";
        done;
      fi

      # Build the normal non-dev target image with all the tags and labels.
      docker pull $CI_IMAGE_REPO/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA
      docker build --cache-from $CI_IMAGE_REPO/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA $FORMATTEDTAGLIST $IMAGE_LABELS -f $DOCKERFILE_PATH.;

      # Push all the tags we just built above
      if [[ -n "$ADDITIONALTAGLIST" ]]; then
        for TAG in $ADDITIONALTAGLIST; do
          TAGGED_IMAGE=$IMAGE_REPO/$IMAGE_NAME:$TAG
          docker push $TAGGED_IMAGE
        done;
      fi

      # Finally we can publish dev-latest for this branch as the latest passed and
      # tested image.
      DEV_LATEST_BRANCH_TAG=$IMAGE_REPO/$IMAGE_NAME:$DEV_LATEST_TAG-$TRUNCATED_BRANCH_NAME
      docker tag $CI_IMAGE_REPO/$IMAGE_NAME:$CI_COMMIT_SHORT_SHA $DEV_LATEST_BRANCH_TAG
      docker push $DEV_LATEST_TAG

# ====================================== BACKEND ======================================
build-backend-image:
  extends: .build-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_SERVICE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_SERVICE_NAME/Dockerfile

backend-lint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $BACKEND_CI_IMAGE lint

backend-test:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
    - name: postgres:11.3
      alias: db
    - name: liminspace/mjml-tcpserver:0.10
      alias: mjml
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    POSTGRES_USER: baserow
    POSTGRES_PASSWORD: baserow
    POSTGRES_DB: baserow
  script:
    - MJML_IP=$(cat /etc/hosts | awk '{if ($2 == "mjml") print $1;}')
    - ping -w 2 $MJML_IP
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - docker run --name=baserow_backend_test_container --add-host="db:$DB_IP" --add-host="mjml:$MJML_IP" $BACKEND_CI_IMAGE ci-test
    - docker cp baserow_backend_test_container:/baserow/backend/reports reports
    - docker rm baserow_backend_test_container
  artifacts:
    when: always
    paths:
      - reports/pytest_report.html
      - reports/coverage_html/
    reports:
      cobertura: reports/coverage.xml
      junit: reports/report.xml

publish-backend-image:
  extends: .publish-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_SERVICE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_SERVICE_NAME/Dockerfile

# ==================================== WEB-FRONTEND ====================================
build-web-frontend-image:
  extends: .build-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_SERVICE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_SERVICE_NAME/Dockerfile

web-frontend-eslint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $WEBFRONTEND_CI_IMAGE eslint
web-frontend-stylelint:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --rm $WEBFRONTEND_CI_IMAGE stylelint

web-frontend-test:
  stage: test
  image: docker:19.03.12
  services:
    - docker:19.03.12-dind
  script:
    - docker run --name=baserow_webfrontend_test_container $WEBFRONTEND_CI_IMAGE ci-test
    - docker cp baserow_webfrontend_test_container:/baserow/web-frontend/reports reports
    - docker rm baserow_webfrontend_test_container
  artifacts:
    when: always
    paths:
      - reports/pytest_report.html
      - reports/coverage_html/
    reports:
      cobertura: reports/cobertura-coverage.xml
      junit: reports/junit.xml

publish-web-frontend-image:
  extends: .publish-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_SERVICE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_SERVICE_NAME/Dockerfile
