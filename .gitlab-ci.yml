# Quick Summary:
#
# Some jobs will be skipped or not included depending on if the pipeline is running
# because of a normal merge/push or instead because a git tag was made for a particular
# commit.
#
# IF PIPELINE IS NOT RUNNING DUE TO A TAG THEN IT:
#   1. Builds backend and web-frontend dev images and pushes to gitlab ci image repo.
#   2. Uses these pushed images to run tests and lints on the backend.
#   3. Caching from the ci dev images builds the non-dev images and pushes both dev and
#      non-dev with tags marking them as tested.
# IF LATEST COMMIT ON DEVELOP:
#   4. Push the tested images to the Dockerhub repo under the develop-latest tag.
# IF RUNNING DUE TO TAG ON MASTER:
#   5. Push the tested images to the Dockerhub repo using the git tag as the docker tag.
# IF RUNNING DUE TO TAG ON LATEST COMMIT ON MASTER:
#   6. Push the tested images to the Dockerhub repo under the latest tag.
#
# Dockerhub Image Release Process as implemented below:
# 1. Merge from develop to master
# 2. Wait for the merge commit pipeline on master to build, test and succeed.
# 3. Tag the merge commit in the Gitlab GUI with the git tag being the Baserow version
#    (1.8.2, 1.0, etc).
# 4. The tag will have its own pipeline which will then push the images build in step
#    2 to Dockerhub. If step 2 failed or has not completed yet then this pipeline will
#    fail and not push anything.


stages:
  - build
  - test
  - build-final
  - publish

variables:
  # An image repo which is used for storing and passing images between ci pipeline jobs
  # and also speeding up ci builds by caching from the latest ci image when building.
  CI_IMAGE_REPO: $CI_REGISTRY_IMAGE/ci
  # Any images with tags prefixed with the two variables below will be cleaned up automatically
  # by our gitlab cleanup job (https://gitlab.com/bramw/baserow/-/settings/packages_and_registries).
  #
  # ## Note:
  #   These cleanup tag prefixes are needed as gitlab only supports cleanup by defining
  #   a regex that matches tags, so we can't do cleanup differently based on image name
  #   or repo...
  #
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  CLEANUP_JOB_CI_TAG_PREFIX: ci-latest-
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  TESTED_IMAGE_PREFIX: ci-tested-
  # An image repo where dev and normal images will be stored after they have been
  # successfully built and tested.
  IMAGE_REPO: $CI_REGISTRY_IMAGE/testing
  BACKEND_IMAGE_NAME: backend
  BACKEND_DEV_IMAGE_NAME: backend_dev
  WEBFRONTEND_IMAGE_NAME: web-frontend
  WEBFRONTEND_DEV_IMAGE_NAME: web-frontend_dev
  BACKEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  # Once images are tested they will publish under these names to ensure that any
  # tag only runs of the pipeline can never publish untested images.
  TESTED_BACKEND_CI_IMAGE: $CI_IMAGE_REPO/$BACKEND_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_WEBFRONTEND_CI_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_BACKEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  TESTED_WEBFRONTEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
  DEVELOP_BRANCH_NAME: develop
  # Used to tag the latest images on $DEVELOP_BRANCH_NAME
  DEVELOP_LATEST_TAG: develop-latest
  MASTER_BRANCH_NAME: 736-build-and-publish-backend-and-web_frontend-docker-images

# ============== "Abstract" ci stages used by later real stages =======================

# Builds a dev version of a specific Dockerfile (--target dev) using a previous CI
# image or the latest develop image as a cache to speed up the build. Tags and pushes
# the resulting dev image for later stages in the pipeline to use.
#
# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:19.03.12
  stage: build
  # Prevent rebuilds when tagging as all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi


      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      CI_DEV_LATEST_BRANCH_TAG=$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CI_DEV_LATEST_BRANCH_TAG"
      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

          # If that didnt work try the latest dev image from develop
          CACHE_IMAGE="$IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
      fi

      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        CACHE_ARG="--cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
        CACHE_ARG=""
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image path also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached so builds caching from this image can use those layers.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image.
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build --build-arg BUILDKIT_INLINE_CACHE=1 $CACHE_ARG --target dev --tag $CI_IMAGE_PATH --tag $LATEST_CI_IMAGE -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# Builds a non-dev (no docker build target provided) and fully labelled final image
# and tags and pushes the non-dev and dev images using $TESTED_IMAGE_PREFIX to mark
# them as being successfully tested for the publishing jobs to use.
#
# To extend this stage set the DOCKERFILE_PATH, IMAGE_NAME and DEV_IMAGE_NAME variables.
.build-final-baserow-image:
  image: docker:19.03.12
  stage: build-final
  # Prevent rebuilds when tagging as all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$IMAGE_REPO:$CI_COMMIT_REF_NAME
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$IMAGE_NAME" ]]; then
          echo "Must provide IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable" 2>&1
          exit 1
      fi

      # ===== 1. Setup image metadata labels =====
      echo "Building and shipping image to $IMAGE_REPO"
      #Build date for opencontainers
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'" #rfc 3339 date
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE --label build-date=$BUILDDATE"
      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE --label org.opencontainers.image.description=$BUILDTITLE"

      # ==== 2. Tag, build and push non-dev image ====

      # Cache from the CI dev image to build the non dev image.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
      TARGET_NON_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA
      TARGET_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$TESTED_IMAGE_PREFIX$CI_COMMIT_SHORT_SHA

      docker pull $CI_IMAGE_PATH
      # Build the normal non-dev image with all the tags and labels.
      docker build --cache-from $CI_IMAGE_PATH $FORMATTEDTAGLIST $IMAGE_LABELS -t $TARGET_NON_DEV_IMAGE_PATH -f $DOCKERFILE_PATH .;
      docker push $TARGET_NON_DEV_IMAGE_PATH

      docker tag $CI_IMAGE_PATH $TARGET_DEV_IMAGE_PATH
      docker push $TARGET_DEV_IMAGE_PATH

# A simple docker based test job which does not run for a TAG pipeline and does not
# check out git.
.docker-image-test-stage:
  stage: test
  image: docker:19.03.12
  # Prevent rebuilds when tagging as all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  variables:
    # We are just running tests in pulled docker images, no need for the source.
    GIT_STRATEGY: none
  services:
    - docker:19.03.12-dind


# Pushes $SOURCE_IMAGE to $TARGET_IMAGE using the $TARGET_REGISTRY_PASSWORD,
# $TARGET_REGISTRY_USER and $TARGET_REGISTRY credentials.
#
# Set $SKIP_IF_TAG_NOT_ON_BRANCH to make the job skip if the commit is not on 
# the specified branch. Useful for TAG pipelines when $CI_COMMIT_BRANCH is not set
# and so we need to do some extra git work to figure out what branches this commit is 
# on.
#
# Set $SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH to a branch name. If the job is not
# for a commit which is the latest on the specified branch name (for example due to
# someone re-running a pipeline for an old commit) this job will be skipped.
.publish-baserow-image:
  image: docker:19.03.12
  stage: publish
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  allow_failure:
    # By exiting with this code we can skip this step without failing the build,
    # but still fail if something else goes wrong.
    exit_codes: 137
  before_script:
    - apk update && apk add curl git jq
  script:
    - |
      if [[ -n "$SKIP_IF_TAG_NOT_ON_BRANCH" ]]; then
        # Query for all the branches that this commit is part of.
        curl -s --header "JOB-TOKEN: $CI_JOB_TOKEN" "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA/refs?type=branch" -o this_commits_branches.json
        # Extract just the branch names from the json so we can assert it matches.
        TAG_BRANCH_NAMES=$(cat this_commits_branches.json | jq -r ".[].name")
        NUM_BRANCHES=$(cat this_commits_branches.json | jq length)
        # Ensure the commit is only on master and no other branches, otherwise someone
        # could checkout a master commit as a new branch and tag it to cause an image
        # upload.
        if [[ "$NUM_BRANCHES" != "1" || "$TAG_BRANCH_NAMES" != "$SKIP_IF_TAG_NOT_ON_BRANCH" ]]; then
          echo "Tags should never be applied to non $SKIP_IF_TAG_NOT_ON_BRANCH branches!" 2>&1;
          echo "Pipeline is running for tag: $CI_COMMIT_TAG which for a commit that only appears on $SKIP_IF_TAG_NOT_ON_BRANCH and no other branches." 2>&1;
          echo "Instead this commit appears on $NUM_BRANCHES branches called $TAG_BRANCH_NAMES" 2>&1;
          exit 1;
        fi
      fi

      if [[ -n "$SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH" ]]; then
        LATEST_COMMIT_HASH=$(git rev-parse origin/$SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH)
        HEAD_COMMIT_HASH=$CI_COMMIT_SHA
        if [[ "$LATEST_COMMIT_HASH" != "$HEAD_COMMIT_HASH" ]]; then
            echo "Pipeline is not running for latest commit on origin/$SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH";
            echo " which has commit $LATEST_COMMIT_HASH.";
            echo "Instead pipeline is running on commit $HEAD_COMMIT_HASH, exitting as configured to do so in this situation...";
            exit 137;
        fi
      fi

      echo "$TARGET_REGISTRY_PASSWORD" | docker login -u "$TARGET_REGISTRY_USER" "$TARGET_REGISTRY" --password-stdin

      if ! docker pull $SOURCE_IMAGE; then
        echo "Could not pull $SOURCE_IMAGE, has the build pipeline finished yet?" 2>&1;
        exit 1
      fi
      docker tag $SOURCE_IMAGE $TARGET_IMAGE
      docker push $TARGET_IMAGE

# ====================================== BACKEND ======================================
build-backend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

backend-lint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $BACKEND_CI_DEV_IMAGE lint

backend-test:
  extends: .docker-image-test-stage
  services:
    - docker:19.03.12-dind
    - name: postgres:11.3
      alias: db
    - name: liminspace/mjml-tcpserver:0.10
      alias: mjml
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    POSTGRES_USER: baserow
    POSTGRES_PASSWORD: baserow
    POSTGRES_DB: baserow
  script:
    - MJML_IP=$(cat /etc/hosts | awk '{if ($2 == "mjml") print $1;}')
    - ping -w 2 $MJML_IP
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - docker run --name=baserow_backend_test_container --add-host="db:$DB_IP" --add-host="mjml:$MJML_IP" $BACKEND_CI_DEV_IMAGE ci-test
    - docker cp baserow_backend_test_container:/baserow/backend/reports reports
    - docker rm baserow_backend_test_container
  artifacts:
    when: always
    paths:
      - reports/pytest_report.html
      - reports/coverage_html/
    reports:
      cobertura: reports/coverage.xml
      junit: reports/report.xml
  coverage: '/^TOTAL.+?(\d+\%)$/'

build-final-backend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_IMAGE_NAME
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

# ==================================== WEB-FRONTEND ====================================
build-web-frontend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile

web-frontend-eslint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $WEBFRONTEND_CI_DEV_IMAGE eslint

web-frontend-stylelint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $WEBFRONTEND_CI_DEV_IMAGE stylelint

web-frontend-test:
  extends: .docker-image-test-stage
  script:
    - mkdir reports/ -p
    - docker run --name=baserow_webfrontend_test_container $WEBFRONTEND_CI_DEV_IMAGE ci-test
    - docker cp baserow_webfrontend_test_container:/baserow/reports reports
    - docker rm baserow_webfrontend_test_container
  artifacts:
    when: always
    paths:
      - reports/coverage/
    reports:
      cobertura: reports/coverage/cobertura-coverage.xml
      junit: reports/junit.xml
  coverage: '/Lines\s*:\s*(\d+.?\d*)%/'

build-web-final-frontend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_IMAGE_NAME
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile


# ================================== PUSHING BACKEND ==================================

# Push baserow/backend:develop_latest
publish-backend-develop-latest-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER


# Push baserow/backend_dev:develop_latest
publish-backend-develop-latest-dev-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_BACKEND_CI_DEV_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# Push baserow/backend:$VERSION_GIT_TAG
publish-backend-release-tagged-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    SKIP_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:$CI_COMMIT_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# Push baserow/backend:latest
publish-backend-latest-release-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $MASTER_BRANCH_NAME
    SKIP_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:latest"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# ================================ PUSHING WEB-FRONTEND ===============================

# Push baserow/web-frontend:develop_latest
publish-webfrontend-develop-latest-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# Push baserow/web-frontend_dev:develop_latest
publish-webfrontend-develop-latest-dev-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_WEBFRONTEND_CI_DEV_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# Push baserow/web-frontend:$VERSION_GIT_TAG
publish-webfrontend-release-tagged-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    SKIP_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$CI_COMMIT_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# Push baserow/web-frontend:latest
publish-webfrontend-latest-release-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    SKIP_IF_NOT_LATEST_COMMIT_ON_BRANCH: $MASTER_BRANCH_NAME
    SKIP_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $TESTED_WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:latest"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER
