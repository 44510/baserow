stages:
  - build
  - test
  - build-final
  - publish

variables:
  DRY_RUN_PUBLISH: "true"
  # An image repo which is used for storing and passing images between ci pipeline jobs
  # and also speeding up ci builds by caching from the latest ci image when building.
  CI_IMAGE_REPO: $CI_REGISTRY_IMAGE/ci
  # Any images with tags prefixed with this will be cleaned up automatically by our
  # gitlab cleanup job.
  #
  # ## Note:
  #   These cleanup tag prefixes are needed as gitlab only supports cleanup via tags
  #   over the regex and not per repo/image cleanup settings...
  #
  # IMPORTANT: UPDATE GITLAB CONTAINER REPO CLEANUP JOB REGEX IF YOU CHANGE THIS
  CLEANUP_JOB_CI_TAG_PREFIX: ci-latest-
  # An image repo where dev and normal images will be stored after they have been
  # successfully built and tested.
  IMAGE_REPO: $CI_REGISTRY_IMAGE/testing
  BACKEND_IMAGE_NAME: backend
  BACKEND_DEV_IMAGE_NAME: backend_dev
  WEBFRONTEND_IMAGE_NAME: web-frontend
  WEBFRONTEND_DEV_IMAGE_NAME: web-frontend_dev
  BACKEND_CI_IMAGE: $CI_IMAGE_REPO/$BACKEND_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  BACKEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  WEBFRONTEND_CI_DEV_IMAGE: $CI_IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
  DEVELOP_BRANCH_NAME: develop
  DEVELOP_LATEST_TAG: develop-latest
  MASTER_BRANCH_NAME: 736-build-and-publish-backend-and-web_frontend-docker-images

# ============== "Abstract" ci stages used by later real stages =======================

# To extend this stage set the DOCKERFILE_PATH and IMAGE_NAME variables.
.build-baserow-image:
  image: docker:19.03.12
  stage: build
  # Prevent rebuilds when tagging all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable"
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable"
          exit 1
      fi


      # Try cache from this branches latest image, if not fall back to the latest
      # develop image.
      # Ensure we don't go over 128 char docker tag length limit
      TRUNCATED_BRANCH_NAME=${CI_COMMIT_REF_NAME:0:100}
      CI_DEV_LATEST_BRANCH_TAG=$CLEANUP_JOB_CI_TAG_PREFIX$TRUNCATED_BRANCH_NAME

      LATEST_CI_IMAGE="$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CI_DEV_LATEST_BRANCH_TAG"
      # ===== 1. Try pull an image we can use to cache the build with =====

      # First try the latest CI image for this branch
      CACHE_IMAGE=$LATEST_CI_IMAGE
      if ! docker pull $CACHE_IMAGE; then

          # If that didnt work try the latest dev image from develop
          CACHE_IMAGE="$IMAGE_REPO/$DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG";
          if ! docker pull $CACHE_IMAGE; then
             CACHE_IMAGE=""
          fi
      fi

      if [[ -n "$CACHE_IMAGE" ]]; then
        echo "Caching docker build from $CACHE_IMAGE";
        CACHE_ARG="--cache-from $CACHE_IMAGE";
      else
        echo "Couldn't find image to cache build using"
        CACHE_ARG=""
      fi

      # This image tag is one that can be used by subsequent build steps, using the
      # latest one might introduce race conditions with concurrent pipelines. Instead
      # by using a simple name + sha we know we will be getting the right image later on
      # and we can easily re-construct this image path also as $CI_COMMIT_SHORT_SHA is
      # available in all stages.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      # ===== 2. Build a dev image to be used in subsequent CI stages =====

      # * Use `--build-arg BUILDKIT_INLINE_CACHE=1` to ensure this image's itermediate
      #    layers will be cached so builds caching from this image can use those layers.
      # * $CACHE_ARG is a --cache-from if we have an existing image that we can use
      #    to speed up this build.
      # * Target the dev image as we want to run tests and linting in this image.
      # * Tag as both the ci image for use in later stages and the latest ci image to
      #   cache any future ci pipeline runs.
      docker build --build-arg BUILDKIT_INLINE_CACHE=1 $CACHE_ARG --target dev --tag $CI_IMAGE_PATH --tag $LATEST_CI_IMAGE -f $DOCKERFILE_PATH .;

      # ===== 3. Push the CI image for the next stages and latest ci image cache =====

      docker push $CI_IMAGE_PATH
      docker push $LATEST_CI_IMAGE

# To extend this stage set the DOCKERFILE_PATH, IMAGE_NAME and DEV_IMAGE_NAME variables.
.build-final-baserow-image:
  image: docker:19.03.12
  stage: build-final
  # Prevent rebuilds when tagging all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_BUILDKIT: 1
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    IMAGE_LABELS: >
      --label org.opencontainers.image.vendor=$CI_PROJECT_URL
      --label org.opencontainers.image.authors=$CI_PROJECT_URL
      --label org.opencontainers.image.revision=$CI_COMMIT_SHA
      --label org.opencontainers.image.source=$CI_PROJECT_URL
      --label org.opencontainers.image.documentation=$CI_PROJECT_URL
      --label org.opencontainers.image.licenses=$CI_PROJECT_URL
      --label org.opencontainers.image.url=$CI_PROJECT_URL
      --label vcs-url=$CI_PROJECT_URL
      --label com.gitlab.ci.user=$CI_SERVER_URL/$GITLAB_USER_LOGIN
      --label com.gitlab.ci.email=$GITLAB_USER_EMAIL
      --label com.gitlab.ci.tagorbranch=$CI_COMMIT_REF_NAME
      --label com.gitlab.ci.pipelineurl=$CI_PIPELINE_URL
      --label com.gitlab.ci.commiturl=$CI_PROJECT_URL/commit/$CI_COMMIT_SHA
      --label com.gitlab.ci.cijoburl=$CI_JOB_URL
      --label com.gitlab.ci.mrurl=$CI_PROJECT_URL/-/merge_requests/$CI_MERGE_REQUEST_ID
      --label org.opencontainers.image.ref.name=$IMAGE_REPO:$CI_COMMIT_REF_NAME
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" "$CI_REGISTRY" --password-stdin
  script:
    - |
      if [[ -z "$DOCKERFILE_PATH" ]]; then
          echo "Must provide DOCKERFILE_PATH as a job variable"
          exit 1
      fi
      if [[ -z "$IMAGE_NAME" ]]; then
          echo "Must provide IMAGE_NAME as a job variable"
          exit 1
      fi
      if [[ -z "$DEV_IMAGE_NAME" ]]; then
          echo "Must provide DEV_IMAGE_NAME as a job variable"
          exit 1
      fi

      # ===== 1. Setup image metadata labels =====
      echo "Building and shipping image to $IMAGE_REPO"
      #Build date for opencontainers
      BUILDDATE="'$(date '+%FT%T%z' | sed -E -n 's/(\+[0-9]{2})([0-9]{2})$/\1:\2/p')'" #rfc 3339 date
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.created=$BUILDDATE --label build-date=$BUILDDATE"
      # Description for opencontainers
      BUILDTITLE="$(echo $CI_PROJECT_TITLE | tr " " "_")_$IMAGE_NAME"
      IMAGE_LABELS="$IMAGE_LABELS --label org.opencontainers.image.title=$BUILDTITLE --label org.opencontainers.image.description=$BUILDTITLE"

      # ==== 2. Tag, build and push non-dev image ====

      # Cache from the CI dev image to build the non dev image.
      CI_IMAGE_PATH=$CI_IMAGE_REPO/$DEV_IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA
      TARGET_NON_DEV_IMAGE_PATH=$CI_IMAGE_REPO/$IMAGE_NAME:$CLEANUP_JOB_CI_TAG_PREFIX$CI_COMMIT_SHORT_SHA

      docker pull $CI_IMAGE_PATH
      # Build the normal non-dev image with all the tags and labels.
      docker build --cache-from $CI_IMAGE_PATH $FORMATTEDTAGLIST $IMAGE_LABELS -t $TARGET_NON_DEV_IMAGE_PATH -f $DOCKERFILE_PATH .;
      docker push $TARGET_NON_DEV_IMAGE_PATH

.docker-image-test-stage:
  stage: test
  image: docker:19.03.12
  # Prevent rebuilds when tagging all we want to do is tag and push the already built image
  except:
    variables:
      - $CI_COMMIT_TAG
  interruptible: true
  variables:
    # We are just running tests in pulled docker images, no need for the source.
    GIT_STRATEGY: none
  services:
    - docker:19.03.12-dind


.publish-baserow-image:
  image: docker:19.03.12
  stage: publish
  interruptible: true
  services:
    - docker:19.03.12-dind
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
  allow_failure:
    # By exiting with this code we can skip this step without failing the build,
    # but still fail if something else goes wrong.
    exit_codes: 137
  before_script:
    - apk update && apk add git jq
  script:
    - |
      if [[ -n "$EXIT_IF_TAG_NOT_ON_BRANCH" ]]; then
        git branch --contains $CI_COMMIT_TAG
        git branch --contains tags/$CI_COMMIT_TAG
        if ! $( git branch --contains $CI_COMMIT_TAG | grep -q $EXIT_IF_TAG_NOT_ON_BRANCH ); then
          echo "Pipeline is running for tag: $CI_COMMIT_TAG which is not on branch $EXIT_IF_TAG_NOT_ON_BRANCH";
          echo "Skipping publish...";
          exit 137;
        fi
      fi

      if [[ -n "$EXIT_IF_NOT_LATEST_COMMIT_ON_REF" ]]; then
        LATEST_COMMIT_HASH=$(git rev-parse $EXIT_IF_NOT_LATEST_COMMIT_ON_REF)
        HEAD_COMMIT_HASH=$(git rev-parse HEAD)
        if [[ "$LATEST_COMMIT_HASH" != "$HEAD_COMMIT_HASH" ]]; then
            echo "Pipeline is not running for latest commit on origin/$EXIT_IF_NOT_LATEST_COMMIT_ON_REF"
            echo " which has commit $LATEST_COMMIT_HASH."
            echo "Instead pipeline is running on commit $HEAD_COMMIT_HASH, exitting as configured to do so in this situation..."
            exit 137
        fi
      fi

      # If a tag has been set we won't have run the build and test steps. Check using
      # the gitlab API if we do actually have a successful build for this commit
      # before pushing any images to repos incase someone has tagged before the build
      # finished.
      if [[ -n "$CI_COMMIT_TAG" ]]; then
        curl --header "JOB_TOKEN: $CI_JOB_TOKEN" "https://gitlab.com/api/v4/projects/$CI_PROJECT_ID/repository/commits/$CI_COMMIT_SHA" -o commit_info.json
        LAST_PIPELINE_STATUS=$(jq --raw-output '.last_pipeline.status' commit_info.json)
        if [[ "$LAST_PIPELINE_STATUS" != "success" ]]; then
          echo "Cannot publish tagged images as there is no successful pipeline run yet for this commit..."
          exit 1
        fi
      fi

      echo "$TARGET_REGISTRY_PASSWORD" | docker login -u "$TARGET_REGISTRY_USER" "$TARGET_REGISTRY" --password-stdin

      if [[ -n "$DRY_RUN_PUBLISH" ]]; then
        echo "docker pull $SOURCE_IMAGE"
        echo "docker tag $SOURCE_IMAGE $TARGET_IMAGE"
        echo "docker push $TARGET_IMAGE"
      else
        docker pull $SOURCE_IMAGE
        docker tag $SOURCE_IMAGE $TARGET_IMAGE
        docker push $TARGET_IMAGE
      fi

# ====================================== BACKEND ======================================
build-backend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

backend-lint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $BACKEND_CI_DEV_IMAGE lint

backend-test:
  extends: .docker-image-test-stage
  services:
    - docker:19.03.12-dind
    - name: postgres:11.3
      alias: db
    - name: liminspace/mjml-tcpserver:0.10
      alias: mjml
  variables:
    DOCKER_HOST: tcp://docker:2376
    DOCKER_TLS_CERTDIR: "/certs"
    POSTGRES_USER: baserow
    POSTGRES_PASSWORD: baserow
    POSTGRES_DB: baserow
  script:
    - MJML_IP=$(cat /etc/hosts | awk '{if ($2 == "mjml") print $1;}')
    - ping -w 2 $MJML_IP
    - DB_IP=$(cat /etc/hosts | awk '{if ($2 == "db") print $1;}')
    - ping -w 2 $DB_IP
    - docker run --name=baserow_backend_test_container --add-host="db:$DB_IP" --add-host="mjml:$MJML_IP" $BACKEND_CI_DEV_IMAGE ci-test
    - docker cp baserow_backend_test_container:/baserow/backend/reports reports
    - docker rm baserow_backend_test_container
  artifacts:
    when: always
    paths:
      - reports/pytest_report.html
      - reports/coverage_html/
    reports:
      cobertura: reports/coverage.xml
      junit: reports/report.xml
  coverage: '/^TOTAL.+?(\d+\%)$/'

build-final-backend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $BACKEND_IMAGE_NAME
    DEV_IMAGE_NAME: $BACKEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$BACKEND_IMAGE_NAME/Dockerfile

# ==================================== WEB-FRONTEND ====================================
build-web-frontend-image:
  extends: .build-baserow-image
  variables:
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile

web-frontend-eslint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $WEBFRONTEND_CI_DEV_IMAGE eslint

web-frontend-stylelint:
  extends: .docker-image-test-stage
  script:
    - docker run --rm $WEBFRONTEND_CI_DEV_IMAGE stylelint

web-frontend-test:
  extends: .docker-image-test-stage
  script:
    - mkdir reports/ -p
    - docker run --name=baserow_webfrontend_test_container $WEBFRONTEND_CI_DEV_IMAGE ci-test > reports/latest_test_output.txt
    - cat reports/latest_test_output.txt
    - docker cp baserow_webfrontend_test_container:/baserow/reports reports
    - docker rm baserow_webfrontend_test_container
  artifacts:
    when: always
    paths:
      - reports/coverage/
    reports:
      cobertura: reports/coverage/cobertura-coverage.xml
      junit: reports/junit.xml
  cache:
    key: "$CI_COMMIT_REF_SLUG"
    paths:
      - reports/
  coverage: '/Lines\s*:\s*(\d+.?\d*)%/'

build-web-final-frontend-image:
  extends: .build-final-baserow-image
  variables:
    IMAGE_NAME: $WEBFRONTEND_IMAGE_NAME
    DEV_IMAGE_NAME: $WEBFRONTEND_DEV_IMAGE_NAME
    DOCKERFILE_PATH: $CI_PROJECT_DIR/$WEBFRONTEND_IMAGE_NAME/Dockerfile


# ================================== PUSHING BACKEND ==================================

publish-backend-develop-latest-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER


publish-backend-develop-latest-dev-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $BACKEND_CI_DEV_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

publish-backend-release-tagged-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    EXIT_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:$CI_COMMIT_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

publish-backend-latest-release-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$MASTER_BRANCH_NAME
    EXIT_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $BACKEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$BACKEND_IMAGE_NAME:latest"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

# ================================ PUSHING WEB-FRONTEND ===============================

publish-webfrontend-develop-latest-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER


publish-webfrontend-develop-latest-dev-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_BRANCH == $DEVELOP_BRANCH_NAME
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$DEVELOP_BRANCH_NAME
    SOURCE_IMAGE: $WEBFRONTEND_CI_DEV_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_DEV_IMAGE_NAME:$DEVELOP_LATEST_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

publish-webfrontend-release-tagged-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    EXIT_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:$CI_COMMIT_TAG"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER

publish-webfrontend-latest-release-image:
  extends: .publish-baserow-image
  only:
    variables:
      - $CI_COMMIT_TAG
  variables:
    EXIT_IF_NOT_LATEST_COMMIT_ON_REF: origin/$MASTER_BRANCH_NAME
    EXIT_IF_TAG_NOT_ON_BRANCH: $MASTER_BRANCH_NAME
    SOURCE_IMAGE: $WEBFRONTEND_CI_IMAGE
    TARGET_IMAGE: "$IMAGE_REPO/$WEBFRONTEND_IMAGE_NAME:latest"
    TARGET_REGISTRY: $CI_REGISTRY
    TARGET_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    TARGET_REGISTRY_USER: $CI_REGISTRY_USER
